// src/address.ts
import { FuelError as FuelError2 } from "@fuel-ts/errors";
import { arrayify as arrayify2, hexlify as hexlify2 } from "@fuel-ts/utils";
import { sha256 as sha2562 } from "@noble/hashes/sha256";

// src/utils.ts
import { randomBytes } from "@fuel-ts/crypto";
import { FuelError } from "@fuel-ts/errors";
import { arrayify, concat, hexlify } from "@fuel-ts/utils";
import { sha256 } from "@noble/hashes/sha256";
function isB256(address) {
  return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);
}
function isPublicKey(address) {
  return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);
}
function isEvmAddress(address) {
  return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);
}
function normalizeB256(address) {
  return address.toLowerCase();
}
function isAddress(address) {
  return "b256Address" in address;
}
var addressify = (addressLike) => {
  if (isAddress(addressLike)) {
    return addressLike;
  }
  if ("address" in addressLike && isAddress(addressLike.address)) {
    return addressLike.address;
  }
  if ("id" in addressLike && isAddress(addressLike.id)) {
    return addressLike.id;
  }
  throw new FuelError(FuelError.CODES.INVALID_ADDRESS, "Invalid address");
};
var getRandomB256 = () => hexlify(randomBytes(32));
var toB256AddressEvm = (b256) => {
  try {
    if (!isB256(b256)) {
      throw new FuelError(FuelError.CODES.INVALID_B256_ADDRESS, `Invalid B256 Address: ${b256}.`);
    }
    const evmBytes = arrayify(b256).slice(12);
    const paddedBytes = new Uint8Array(12).fill(0);
    return hexlify(concat([paddedBytes, evmBytes]));
  } catch (error) {
    throw new FuelError(
      FuelError.CODES.PARSE_FAILED,
      `Cannot generate EVM Address B256 from: ${b256}.`
    );
  }
};
var padFirst12BytesOfEvmAddress = (address) => {
  if (!isEvmAddress(address)) {
    throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
  }
  return address.replace("0x", "0x000000000000000000000000");
};
var fromEvmAddressToB256 = (address) => padFirst12BytesOfEvmAddress(address);
var fromPublicKeyToB256 = (publicKey) => {
  if (!isPublicKey(publicKey)) {
    throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);
  }
  return hexlify(sha256(arrayify(publicKey)));
};
var fromDynamicInputToB256 = (address) => {
  if (typeof address !== "string" && "toB256" in address) {
    return address.toB256();
  }
  if (isB256(address)) {
    return address;
  }
  if (isPublicKey(address)) {
    return fromPublicKeyToB256(address);
  }
  if (isEvmAddress(address)) {
    return fromEvmAddressToB256(address);
  }
  throw new FuelError(
    FuelError.CODES.PARSE_FAILED,
    `Unknown address format: only 'B256', 'Public Key (512)', or 'EVM Address' are supported.`
  );
};

// src/address.ts
var Address = class {
  // #region address-2
  b256Address;
  // #endregion address-2
  /**
   * @param address - A B256 address, public key, EVM address, or Address instance
   */
  constructor(address) {
    const b256Address = fromDynamicInputToB256(address);
    this.b256Address = normalizeB256(b256Address);
  }
  /**
   * Takes an B256 Address and returns back an checksum address.
   * The implementation follows the ERC-55 https://github.com/ethereum/ercs/blob/master/ERCS/erc-55.md.
   *
   * @returns A new `ChecksumAddress` instance
   */
  toChecksum() {
    return Address.toChecksum(this.b256Address);
  }
  /**
   * Returns the `b256Address` property
   */
  toAddress() {
    return this.b256Address;
  }
  /**
   * Returns the B256 hash address as a string
   *
   * @returns The B256 address
   */
  toB256() {
    return this.b256Address;
  }
  /**
   * Returns the B256 hash address as a Uint8Array
   *
   * @returns The B256 address as a Uint8Array
   */
  toBytes() {
    return arrayify2(this.b256Address);
  }
  /**
   * Returns the B256 hash address as a string
   *
   * @returns The B256 address
   */
  toHexString() {
    return this.toB256();
  }
  /**
   * returns the address `checksum` as a string
   *
   * @returns The `b256Address` property as a string
   */
  toString() {
    return this.toChecksum();
  }
  /**
   * Converts and returns the `b256Address` property as a string
   * @returns The `b256Address` property as a JSON string
   */
  toJSON() {
    return this.b256Address;
  }
  /**
   * Converts to an EVM address
   *
   * @returns an {@link EvmAddress | `EvmAddress`} representation of the address
   */
  toEvmAddress() {
    return {
      bits: toB256AddressEvm(this.b256Address)
    };
  }
  /**
   * Wraps the B256 property and returns as an `AssetId`.
   * @returns The B256 property as an {@link AssetId | `AssetId`}
   */
  toAssetId() {
    return {
      bits: this.b256Address
    };
  }
  /**
   * Wraps the B256 address `checksum` and returns it as a string
   * @returns The B256 address `checksum` as a string
   */
  valueOf() {
    return this.toChecksum();
  }
  /**
   * Compares this the `b256Address` property to another for direct equality
   * @param other - Another address to compare against
   * @returns The equality of the comparison
   */
  equals(other) {
    return this.toChecksum() === other.toChecksum();
  }
  /**
   * Takes a Public Key, hashes it, and creates an `Address`
   *
   * @param publicKey - A wallets public key
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromPublicKey(publicKey) {
    const b256Address = fromPublicKeyToB256(publicKey);
    return new Address(b256Address);
  }
  /**
   * Takes a B256 Address and creates an `Address`
   *
   * @param b256Address - A b256 hash
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromB256(b256Address) {
    if (!isB256(b256Address)) {
      throw new FuelError2(
        FuelError2.CODES.INVALID_B256_ADDRESS,
        `Invalid B256 Address: ${b256Address}.`
      );
    }
    return new Address(b256Address);
  }
  /**
   * Creates an `Address` with a randomized `b256Address` property
   *
   * @returns A new `Address` instance
   */
  static fromRandom() {
    return new Address(getRandomB256());
  }
  /**
   * Takes an ambiguous string and attempts to create an `Address`
   *
   * @param address - An ambiguous string
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromString(address) {
    return new Address(address);
  }
  /**
   * Takes an ambiguous string or address and creates an `Address`
   *
   * @returns a new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromAddressOrString(address) {
    return new Address(address);
  }
  /**
   * Takes a dynamic string or `Address` and creates an `Address`
   *
   * @param addressId - A string containing B256, or Public Key
   * @throws Error - Unknown address if the format is not recognised
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromDynamicInput(address) {
    return new Address(address);
  }
  /**
   * Takes an Evm Address and returns back an `Address`
   *
   * @returns A new `Address` instance
   *
   * @deprecated Use `new Address` instead
   */
  static fromEvmAddress(evmAddress) {
    if (!isEvmAddress(evmAddress)) {
      throw new FuelError2(
        FuelError2.CODES.INVALID_EVM_ADDRESS,
        `Invalid Evm Address: ${evmAddress}.`
      );
    }
    return new Address(evmAddress);
  }
  /**
   * Takes an ChecksumAddress and validates if it is a valid checksum address.
   *
   * @returns A `boolean` instance indicating if the address is valid.
   */
  static isChecksumValid(address) {
    let addressParsed = address;
    if (!address.startsWith("0x")) {
      addressParsed = `0x${address}`;
    }
    if (addressParsed.trim().length !== 66) {
      return false;
    }
    return Address.toChecksum(hexlify2(addressParsed)) === addressParsed;
  }
  /** @hidden */
  static toChecksum(address) {
    if (!isB256(address)) {
      throw new FuelError2(
        FuelError2.CODES.INVALID_B256_ADDRESS,
        `Invalid B256 Address: ${address}.`
      );
    }
    const addressHex = hexlify2(address).toLowerCase().slice(2);
    const checksum = sha2562(addressHex);
    let ret = "0x";
    for (let i = 0; i < 32; ++i) {
      const byte = checksum[i];
      const ha = addressHex.charAt(i * 2);
      const hb = addressHex.charAt(i * 2 + 1);
      ret += (byte & 240) >= 128 ? ha.toUpperCase() : ha;
      ret += (byte & 15) >= 8 ? hb.toUpperCase() : hb;
    }
    return ret;
  }
};
export {
  Address,
  addressify,
  fromDynamicInputToB256,
  fromEvmAddressToB256,
  fromPublicKeyToB256,
  getRandomB256,
  isAddress,
  isB256,
  isEvmAddress,
  isPublicKey,
  normalizeB256,
  padFirst12BytesOfEvmAddress,
  toB256AddressEvm
};
//# sourceMappingURL=index.mjs.map